# Java Garbage Collection
```md
1.GC算法：
	1、引用计数法：在对象中添加了一个引用计数器，当有地方引用这个对象时，引用计数器的值就加1
  ，当引用失效的时候，引用计数器的值就减1。
  当引用计数器的值为0时，JVM就开始回收这个对象(弊端：存在对象间互相引用)
	2、可达性分析法：以"GC Roots"的对象作为起始点向下搜索
  ，搜索所走过的路径称为引用链(Reference Chain)，
  当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的
  ，即可以进行垃圾回收。否则，证明这个对象有用，不是垃圾。
	(在可达性分析算法中不可达的对象，并不是直接被回收，这时它们处于缓刑状态，至少需要进行两次标记才会确定该对象是否被回收)
1.1.GC Roots:
（1） 虚拟机栈（栈帧中本地变量表）中引用的对象；
（2） 方法区中类静态属性引用的对象；
（3） 方法区中常量引用的对象；
（4） 本地方法栈中JNI（Native方法）引用的对象。
2.垃圾回收运作方式：
	串行执行：垃圾回收器执行的时候应用程序挂起，串行执行指的是垃圾回收器有且仅有一个后台线程执行垃圾对象的识别和回收；
	并行执行：垃圾回收器执行的时候应用程序挂起，但是在暂停期间会有多个线程进行识别和回收，可以减少垃圾回收时间；
	并发执行：垃圾回收器执行期间，应用程序不用挂起正常运行（当然在某些必要的情况下垃圾回收器还是需要挂起的）
3.三色标记法：
	白色：还未被垃圾回收器标记的对象
	灰色：自身已经被标记，但其拥有的成员变量还未被标记
	黑色：自身已经被标记，且对象本身所有的成员变量也已经被标记
4.读屏障(增量更新)&&写屏障
	4.1浮标
	4.2漏标
5.垃圾回收算法
	标记-清除算法(标记和清除两个过程都比较耗时，效率不高、清除后会产生大量不连续的内存碎片空间)
	标记-复制算法(内存空间利用率低,适用于那些生命周期短、回收频率高的内存对象，如Yong区)
	标记-压缩(整理)算法(回收效率低适用于那些生命周期长、回收频率低，但注重回收一次内存空间得到足够释放的场景，如Old区)
	分代算法
	增量算法
	并发算法
6.垃圾回收器
	G1(Garbage First)垃圾回收器：
		1.内存逻辑上仍保留的分代的概念，每一个Region同一时间要么被标记为新生代，要么被标记为老年代，要么处于空闲；
		2.整体上采用了“标记-整理算法”，不会产生内存碎片
		3.可预测的停顿，G1整体采用的策略是“筛选回收”，也就是回收前会对各个待回收的Region的回收价值和成本进行排序，
    根据G1配置所期望的回收时间，选择排在前面的几个Region进行回收。
	ZGC：Zero GC(JDK11)
```

### 堆类别
---
+ 年轻代(Yong)
+ 年老代(Tenured)
+ 永久代(Perm)
### JVM参数
---
+ -Xmx512m
```
设置JVM实例堆最大可用内存为512M。
```
+ -Xms512m:
```
设置JVM初始内存为512m。
此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。
```
+ -Xmn192m
```
设置年轻代大小为192m。整个JVM内存大小=年轻代大小 + 年老代大小 + 持久代大小。
持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。
此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。
```
+ -Xss128k
```
设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。
根据应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。
但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。
```
+ -XX:NewRatio=4
```
设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。
设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5
```
+ -XX:SurvivorRatio=4 
```
设置年轻代中Eden区与Survivor区的大小比值。
设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6
````
+ -XX:PermSize=128M 
```
设置持久代大小为128M 
```
+ -XX:MaxPermSize=16m 
```
设置持久代最大为16m。 
MaxPermSize过小会导致：java.lang.OutOfMemoryError: PermGen space
```
+ -XX:MaxTenuringThreshold=0 
```
设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。
对于年老代比较多的应用，可以提高效率。如果将此值设置为一个较大值，
则年轻代对象会在Survivor区进行多次复制，
这样可以增加对象再年轻代的存活时间，增加在年轻代即被回收的概论。
```
+ -XX:+UseCMSCompactAtFullCollection
```
使用并发收集器时，开启对年老代的压缩。
``` 
+ -XX:CMSFullGCsBeforeCompaction=0
```
上面配置开启的情况下，这里设置多少次Full GC后，对年老代进行压缩
```
### 参考资料
---
[JVM 参数s](http://blog.csdn.net/mrzhoug/article/details/51148302)
